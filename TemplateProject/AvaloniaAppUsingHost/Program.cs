using System;
using System.Diagnostics;
using System.Threading.Tasks;
using Avalonia;

namespace AvaloniaAppUsingHost;

internal sealed class Program
{
    // Note. Large parts of the exception handling has been generated by AI
    
    // Note that in the App.axam.cs file we also hook up error handling that will write an error to the status message
    // of the MainWindowViewModel on errors on the Dispatcher.UIThread
    
    // Initialization code. Don't use any Avalonia, third-party APIs or any
    // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
    // yet and stuff might break.
    [STAThread]
    public static void Main(string[] args)
    {
        // Register global exception handlers as early as possible
        AppDomain.CurrentDomain.UnhandledException += CurrentDomainOnUnhandledException;
        TaskScheduler.UnobservedTaskException += TaskSchedulerOnUnobservedTaskException;

        try
        {
            BuildAvaloniaApp()
                .StartWithClassicDesktopLifetime(args);
        }
        catch (Exception ex)
        {
            // Last‑resort guard for any exceptions escaping the Avalonia lifetime
            SafeLogCritical("A fatal error occurred in the application lifetime.", ex);
            throw; // Preserve original crash behavior after logging
        }
    }

    // Avalonia configuration, don't remove; also used by visual designer.
    public static AppBuilder BuildAvaloniaApp()
    {
        return AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .WithInterFont()
            .LogToTrace();
    }

    private static void CurrentDomainOnUnhandledException(object? sender, UnhandledExceptionEventArgs e)
    {
        var ex = e.ExceptionObject as Exception ?? new Exception($"Non-Exception unhandled error: {e.ExceptionObject}");
        var terminating = e.IsTerminating ? " (terminating)" : string.Empty;
        SafeLogCritical($"Unhandled exception on AppDomain{terminating}.", ex);
    }

    private static void TaskSchedulerOnUnobservedTaskException(object? sender, UnobservedTaskExceptionEventArgs e)
    {
        SafeLogCritical("Unobserved task exception.", e.Exception);
        // Consider preventing process crash due to unobserved exceptions
        e.SetObserved();
    }

    private static void SafeLogCritical(string message, Exception ex)
    {
        // We can't rely on DI logging this early; write to stderr and trace
        try
        {
            Console.Error.WriteLine($"[CRITICAL] {DateTime.Now:O} {message} {ex}");
        }
        catch
        {
            // ignored
        }

        try
        {
            Trace.TraceError($"[CRITICAL] {message} {ex}");
        }
        catch
        {
            // ignored
        }
    }
}